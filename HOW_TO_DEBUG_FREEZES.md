# Как обнаружить проблему зависания ESP32

## Добавленные инструменты диагностики

### 1. Watchdog Timer (WDT)
- **Автоматически перезапускает ESP32** если `loop()` не выполняется более 30 секунд
- **Инициализируется** в `setup()`
- **Сбрасывается** в начале каждого `loop()`
- **Если ESP32 постоянно перезагружается** - значит есть блокирующая операция в `loop()`

### 2. Heartbeat (Счетчик итераций)
- **Счетчик** увеличивается каждую итерацию `loop()`
- **Логируется в Serial** каждые 10000 итераций (примерно раз в минуту)
- **Мониторится через API** `/api/diagnostics`
- **Если счетчик не растет** - значит `loop()` завис

### 3. API Диагностики
**Endpoint**: `GET /api/diagnostics`

**Возвращает**:
```json
{
  "freeHeap": 250000,
  "minFreeHeap": 240000,
  "maxAllocHeap": 50000,
  "heapSize": 327680,
  "uptime": 3600,
  "uptimeFormatted": "1h 0m 0s",
  "cpuLoad": 15.5,
  "wifiStatus": "Connected",
  "wifiRSSI": -45,
  "wifiIP": "192.168.0.197",
  "mqttConnected": true,
  "mqttEnabled": true,
  "heartbeatPerMinute": 15000,
  "systemEnabled": true,
  "systemState": "HEATING",
  "warnings": []
}
```

**Предупреждения** (массив `warnings`):
- `"Low free heap memory"` - свободной памяти < 50KB
- `"Very low minimum free heap"` - минимальная свободная память < 30KB
- `"High CPU load"` - загрузка CPU > 80%
- `"Low heartbeat - possible freeze"` - heartbeat < 100/мин (возможное зависание)
- `"WiFi disconnected"` - WiFi отключен
- `"MQTT disconnected"` - MQTT отключен при включенном MQTT

### 4. Мониторинг памяти в статусе
**Endpoint**: `GET /api/status`

Теперь включает:
- `freeHeap` - текущая свободная память
- `minFreeHeap` - минимальная свободная память с момента запуска
- `cpuLoad` - загрузка CPU в процентах
- `uptime` - время работы в секундах

## Как использовать

### 1. Мониторинг через Serial Monitor
Откройте Serial Monitor (115200 baud) и следите за сообщениями:
```
[DIAG] Heartbeat #10000 | Free heap: 250000 bytes | Min free: 240000 bytes | Uptime: 60 sec
```

**Если сообщения не появляются** - значит `loop()` завис.

### 2. Мониторинг через веб-интерфейс
Откройте в браузере: `http://IP_ESP32/api/diagnostics`

Проверьте:
- **heartbeatPerMinute** - должно быть > 1000 (нормально 10000-20000)
- **freeHeap** - должно быть > 50000 байт
- **warnings** - массив предупреждений

### 3. Автоматический перезапуск при зависании
Watchdog автоматически перезапустит ESP32 если:
- `loop()` не выполняется более 30 секунд
- Есть блокирующая операция без `yield()`

**Признак**: ESP32 постоянно перезагружается, в Serial видны сообщения о перезагрузке.

## Типичные проблемы

### Проблема: ESP32 постоянно перезагружается
**Причина**: Блокирующая операция в `loop()` без `yield()`
**Решение**: 
- Найти блокирующие `delay()` без `yield()`
- Проверить длительные операции (чтение датчиков, WiFi, MQTT)
- Добавить `yield()` в циклы

### Проблема: Heartbeat не растет
**Причина**: `loop()` завис в какой-то функции
**Решение**:
- Проверить Serial Monitor - последнее сообщение покажет где зависло
- Добавить логирование в подозрительные функции
- Проверить бесконечные циклы

### Проблема: Низкая свободная память
**Причина**: Утечка памяти или слишком большие буферы
**Решение**:
- Проверить динамическое выделение памяти
- Уменьшить размер буферов
- Проверить освобождение ресурсов

### Проблема: Высокая загрузка CPU
**Причина**: Слишком частые операции или тяжелые вычисления
**Решение**:
- Увеличить интервалы между операциями
- Оптимизировать вычисления
- Использовать асинхронные операции

## Примеры использования

### Проверка через curl:
```bash
curl http://192.168.0.197/api/diagnostics
```

### Проверка через браузер:
Откройте: `http://IP_ESP32/api/diagnostics`

### Мониторинг в реальном времени:
```bash
watch -n 5 'curl -s http://192.168.0.197/api/diagnostics | jq .'
```

## Что делать при обнаружении проблемы

1. **Проверить Serial Monitor** - найти последнее сообщение
2. **Проверить `/api/diagnostics`** - посмотреть предупреждения
3. **Проверить `/api/status`** - посмотреть состояние системы
4. **Найти проблемную функцию** по последнему логу
5. **Исправить блокирующую операцию** или добавить `yield()`
