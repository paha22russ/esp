# Архитектура системы сбора данных и ML обучения

## Как работает текущее приложение

### 1. Поток данных

```
ESP32 (Котел) 
    ↓ (MQTT публикация каждые 10 сек)
MQTT Брокер (m5.wqtt.ru:5374)
    ↓ (MQTT подписка)
GUI Приложение (Windows)
    ↓
    ├─→ Визуализация (окно приложения)
    └─→ Сохранение (data/ml_data_*.jsonl)
```

### 2. Компоненты приложения

#### **MQTT Клиент** (`src/mqtt_client.py`)
- Подключается к MQTT брокеру
- Подписывается на топик `kotel/device1/ml/data`
- Получает JSON сообщения в реальном времени
- Автоматическое переподключение при разрыве связи

#### **Обработчик данных** (`src/data_processor.py`)
- Парсит JSON сообщения
- Преобразует типы данных (float, int, bool)
- Форматирует значения для отображения (время работы, память, RSSI)

#### **Сохранение данных** (`src/data_saver.py`)
- Сохраняет каждое сообщение в файл формата **JSON Lines** (`.jsonl`)
- Каждая строка = один JSON объект
- Имя файла: `ml_data_YYYY-MM-DD_HH-MM-SS.jsonl`
- Папка: `data/`

#### **GUI Интерфейс** (`src/gui_main.py` + `src/widgets/`)
- Отображает данные в реальном времени
- Графики температур
- Статистика и системная информация

## Куда собираются данные

### Формат файлов

**JSON Lines (`.jsonl`)** - каждая строка это отдельный JSON объект:

```json
{"timestamp": 1704312000, "supplyTemp": 65.5, "returnTemp": 45.2, "fan": true, ...}
{"timestamp": 1704312010, "supplyTemp": 66.2, "returnTemp": 45.8, "fan": true, ...}
{"timestamp": 1704312020, "supplyTemp": 67.1, "returnTemp": 46.1, "fan": false, ...}
```

### Расположение

- **Папка:** `data/`
- **Имя файла:** `ml_data_2026-01-03_21-25-32.jsonl`
- **Структура:** Один файл на сессию сбора данных

### Что сохраняется

Каждое сообщение содержит:
- **Температуры:** подача, обратка, котел, улица, разница
- **Состояния:** вентилятор, насос, система, состояние
- **Настройки:** уставка, мин/макс температура, гистерезис
- **Время:** timestamp, время работы, дата/время
- **Система:** WiFi, память, датчики

## Что делать дальше: ML модель для предсказания и управления

### Этап 2: Анализ и предобработка данных

#### 2.1 Сбор достаточного объема данных
- **Минимум:** 1-2 недели работы котла в разных режимах
- **Цель:** 10,000+ записей (при интервале 10 сек = ~28 часов)
- **Разнообразие:** разные температуры на улице, режимы работы

#### 2.2 Анализ данных
Создать скрипт для анализа:
```python
# src/analysis/data_explorer.py
- Загрузка всех .jsonl файлов
- Статистика: средние, минимум, максимум
- Корреляции между параметрами
- Визуализация временных рядов
- Обнаружение аномалий
```

#### 2.3 Предобработка для ML
- **Нормализация** температур и других числовых значений
- **Обработка пропусков** (если есть)
- **Создание признаков:**
  - Производные: скорость изменения температуры
  - Временные: час дня, день недели
  - Логические: комбинации состояний устройств

### Этап 3: Разработка ML модели

#### 3.1 Задачи модели

**Вариант A: Предсказание температуры**
- **Вход:** текущие температуры, состояния, настройки, время
- **Выход:** температура подачи через N минут (5, 10, 30)
- **Модель:** LSTM, GRU или Transformer (для временных рядов)

**Вариант B: Предсказание оптимальных действий**
- **Вход:** текущее состояние системы
- **Выход:** рекомендуемые действия (включить/выключить вентилятор, насос)
- **Модель:** Классификация или Reinforcement Learning

**Вариант C: Предсказание состояния**
- **Вход:** текущие параметры
- **Выход:** вероятность перегрева, оптимальное время подброса угля
- **Модель:** Классификация или Регрессия

#### 3.2 Рекомендуемый подход

**Гибридная модель:**
1. **LSTM/GRU** для предсказания температуры на 10-30 минут вперед
2. **Правила + ML** для принятия решений:
   - Если предсказанная температура > уставка + гистерезис → выключить вентилятор
   - Если предсказанная температура < уставка - гистерезис → включить вентилятор
   - ML модель корректирует правила на основе исторических данных

#### 3.3 Структура проекта для ML

```
ml_training_project/
├── src/
│   ├── analysis/              # Анализ данных
│   │   ├── data_explorer.py
│   │   ├── data_cleaner.py
│   │   └── feature_engineering.py
│   ├── models/                # ML модели
│   │   ├── temperature_predictor.py
│   │   ├── action_recommender.py
│   │   └── model_trainer.py
│   └── evaluation/            # Оценка моделей
│       ├── metrics.py
│       └── visualizer.py
├── notebooks/                 # Jupyter notebooks для экспериментов
│   ├── 01_data_exploration.ipynb
│   ├── 02_feature_engineering.ipynb
│   └── 03_model_training.ipynb
└── models/                    # Сохраненные обученные модели
    ├── temperature_lstm.h5
    └── action_classifier.pkl
```

### Этап 4: Обучение модели

#### 4.1 Подготовка данных
```python
# Пример структуры данных для обучения
X (признаки):
- Температуры: supplyTemp, returnTemp, boilerTemp, outdoorTemp
- Состояния: fan, pump, systemEnabled (0/1)
- Настройки: setpoint, minTemp, maxTemp
- Временные: hour, day_of_week, time_since_start
- Производные: tempDiff, temp_change_rate

y (целевая переменная):
- Вариант A: supplyTemp через 10 минут
- Вариант B: оптимальное действие (0=выкл, 1=вкл вентилятор)
```

#### 4.2 Разделение данных
- **Обучение:** 70% данных
- **Валидация:** 15% данных
- **Тестирование:** 15% данных

#### 4.3 Обучение
- Использовать библиотеки: `tensorflow/keras` или `scikit-learn`
- Метрики: MAE, RMSE для регрессии; Accuracy, F1 для классификации
- Сохранение лучшей модели

### Этап 5: Интеграция модели в систему управления

#### 5.1 Добавление ML режима в ESP32

**Новый режим работы:**
- **AUTO** - текущий режим (правила)
- **ML** - управление через ML модель

#### 5.2 Архитектура ML управления

```
ESP32 (Котел)
    ↓ (публикует данные)
MQTT Брокер
    ↓
ML Сервис (Python)
    ├─→ Загружает обученную модель
    ├─→ Получает данные от ESP32
    ├─→ Предсказывает оптимальное действие
    └─→ Публикует команды в топик управления
        ↓
ESP32 (получает команды и выполняет)
```

#### 5.3 Топики MQTT для управления

- **Вход:** `kotel/device1/ml/data` (текущие данные)
- **Выход:** `kotel/device1/ml/command` (команды управления)
  ```json
  {
    "fan": true/false,
    "pump": true/false,
    "setpoint": 60.0,
    "confidence": 0.95
  }
  ```

#### 5.4 Безопасность
- Проверка предсказаний на разумность (температура в допустимых пределах)
- Fallback на AUTO режим при ошибках ML
- Логирование всех решений ML модели

## Рекомендации по сбору данных

### Что важно собирать:

1. **Разные сезоны:** зима, весна, осень (разные температуры на улице)
2. **Разные режимы работы:** утро, день, вечер, ночь
3. **Экстремальные ситуации:** перегрев, охлаждение, подброс угля
4. **Разные настройки:** разные уставки, гистерезисы

### Минимальный объем для обучения:
- **Базовый:** 5,000 записей (~14 часов)
- **Хороший:** 20,000 записей (~56 часов, 2-3 дня)
- **Отличный:** 50,000+ записей (~140 часов, неделя)

## Следующие шаги (приоритет)

1. ✅ **Сбор данных** (текущий этап) - продолжайте собирать данные
2. **Анализ данных** - создайте скрипты для анализа собранных данных
3. **Разработка модели** - начните с простой модели (линейная регрессия), затем LSTM
4. **Валидация** - проверьте модель на тестовых данных
5. **Интеграция** - добавьте ML режим в ESP32

## Полезные библиотеки для ML

```python
# Для анализа данных
pandas>=2.1.0          # Обработка данных
numpy>=1.24.0          # Численные операции
matplotlib>=3.8.0      # Визуализация
seaborn                # Расширенная визуализация

# Для ML
scikit-learn>=1.3.0    # Классические ML модели
tensorflow>=2.13.0     # Глубокое обучение (LSTM)
# или
pytorch>=2.0.0         # Альтернатива TensorFlow

# Для временных рядов
statsmodels            # Статистические модели
prophet                # Прогнозирование временных рядов (Facebook)
```

